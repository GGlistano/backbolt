require('dotenv').config(); // local dev; no Railway ignora

const express = require('express');
const axios = require('axios');
const cors = require('cors');
const crypto = require('crypto');
const nodemailer = require('nodemailer');
const path = require('path');
const fs = require('fs');
const jwt = require('jsonwebtoken');

/* ---------------------------------------------
   Firebase Admin
----------------------------------------------*/
const admin = require('firebase-admin');

// Configura√ß√£o do Firebase Admin
let serviceAccount;
try {
  if (process.env.FIREBASE_SERVICE_ACCOUNT) {
    serviceAccount = JSON.parse(process.env.FIREBASE_SERVICE_ACCOUNT);
  } else {
    serviceAccount = require('./serviceAccountKey.json');
  }
} catch (error) {
  console.error('‚ùå Erro ao carregar credenciais do Firebase:', error.message);
  process.exit(1);
}

admin.initializeApp({
  credential: admin.credential.cert(serviceAccount),
  databaseURL: process.env.FIREBASE_DATABASE_URL
});

const db = admin.firestore();

/* ---------------------------------------------
   Express Setup
----------------------------------------------*/
const app = express();

app.use(cors());
app.use(express.json());
app.use(express.static('public'));

const PORT = process.env.PORT || 3000;

// Chave secreta para JWT (adicione no seu .env)
const JWT_SECRET = process.env.JWT_SECRET || 'sua-chave-secreta-super-forte-aqui';

// Debug r√°pido de envs cr√≠ticos (n√£o loga secretos!)
console.log('üîß CLIENT_ID:', process.env.CLIENT_ID ? 'OK' : 'MISSING');
console.log('üîß E2_BASE_URL:', process.env.E2_BASE_URL || 'MISSING');
console.log('üîß MPESA_WALLET_ID:', process.env.MPESA_WALLET_ID ? 'OK' : 'MISSING');
console.log('üîß EMOLA_WALLET_ID:', process.env.EMOLA_WALLET_ID ? 'OK' : 'MISSING');

/* ---------------------------------------------
   Nodemailer Setup
----------------------------------------------*/
const transporter = nodemailer.createTransporter({
  service: 'gmail',
  auth: {
    user: process.env.EMAIL_USER,
    pass: process.env.EMAIL_PASS
  }
});

/* ---------------------------------------------
   Utilit√°rios
----------------------------------------------*/
function formatPhoneNumber(n) {
  if (!n) return '';
  n = n.toString().replace(/\D/g, '');
  return n.startsWith('+') ? n : `+${n}`;
}

/* ---------------------------------------------
   JWT Utils para Upsell
----------------------------------------------*/
function gerarUpsellToken(dadosCliente) {
  const payload = {
    msisdn: dadosCliente.phone,
    method: dadosCliente.metodo,
    email: dadosCliente.email,
    nome: dadosCliente.nome,
    whatsapp: dadosCliente.whatsapp,
    parentTxn: dadosCliente.reference,
    iat: Math.floor(Date.now() / 1000),
    exp: Math.floor(Date.now() / 1000) + (30 * 60) // 30 minutos
  };
  
  return jwt.sign(payload, JWT_SECRET);
}

function validarUpsellToken(token) {
  try {
    return jwt.verify(token, JWT_SECRET);
  } catch (error) {
    throw new Error('Token inv√°lido ou expirado');
  }
}

async function verificarTransacaoPrincipal(parentTxn) {
  try {
    const snapshot = await db.collection('compras')
      .where('reference', '==', parentTxn)
      .get();
    
    return !snapshot.empty;
  } catch (error) {
    console.error('Erro ao verificar transa√ß√£o principal:', error);
    return false;
  }
}

async function verificarUpsellJaProcessado(parentTxn, upsellLevel) {
  try {
    const colecao = `upsell${upsellLevel}_compras`;
    const snapshot = await db.collection(colecao)
      .where('parentTxn', '==', parentTxn)
      .get();
    
    return !snapshot.empty;
  } catch (error) {
    console.error('Erro ao verificar upsell processado:', error);
    return false;
  }
}

/* ---------------------------------------------
   Rota Principal de Compra
----------------------------------------------*/
app.post('/api/comprar', async (req, res) => {
  const { phone, metodo, email, nome: nomeCliente, whatsapp } = req.body;

  // valida√ß√µes b√°sicas
  if (!phone || !metodo || !email) {
    return res.status(400).json({ status: 'error', message: 'Campos obrigat√≥rios: phone, metodo, email' });
  }

  if (!['mpesa', 'emola'].includes(metodo)) {
    return res.status(400).json({ status: 'error', message: 'M√©todo deve ser mpesa ou emola' });
  }

  try {
    // 1) determinar wallet e token
    let walletId, token;
    if (metodo === 'mpesa') {
      walletId = process.env.MPESA_WALLET_ID;
      token = process.env.MPESA_TOKEN;
    } else {
      walletId = process.env.EMOLA_WALLET_ID;
      token = process.env.EMOLA_TOKEN;
    }

    if (!walletId || !token) {
      return res.status(500).json({ status: 'error', message: `Configura√ß√£o ${metodo} n√£o encontrada` });
    }

    // 2) gerar refer√™ncia √∫nica
    const reference = `TXN-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;

    // 3) URL da API externa
    const url = `${process.env.E2_BASE_URL}/v1/c2b/${metodo}-payment/${walletId}`;

    // 4) chamada para API externa de pagamento
    const response = await axios.post(
      url,
      {
        client_id: process.env.CLIENT_ID,
        amount: '99',
        phone,
        reference,
      },
      {
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`,
        },
      }
    );

    // 5) salvar compra no Firebase
    await db.collection('compras').add({
      nome: nomeCliente || '',
      email,
      phone,
      whatsapp: whatsapp || '',
      metodo,
      amount: 99,
      reference,
      created_at: new Date(),
    });

    // 6) enviar email de confirma√ß√£o
    const mailOptions = {
      from: process.env.EMAIL_USER,
      to: email,
      subject: 'Confirma√ß√£o de Compra - Ebook Receitas',
      html: `
        <h2>Obrigado pela sua compra!</h2>
        <p>Ol√° ${nomeCliente || 'Cliente'},</p>
        <p>Sua compra foi processada com sucesso.</p>
        <p><strong>Refer√™ncia:</strong> ${reference}</p>
        <p><strong>Valor:</strong> 99 MT</p>
        <p><strong>M√©todo:</strong> ${metodo.toUpperCase()}</p>
        <p>Em breve voc√™ receber√° o link para download do seu ebook.</p>
        <br>
        <p>Atenciosamente,<br>Equipe Receitas</p>
      `
    };

    try {
      await transporter.sendMail(mailOptions);
      console.log('‚úÖ Email enviado para:', email);
    } catch (emailError) {
      console.error('‚ùå Erro ao enviar email:', emailError.message);
    }

    // 7) log de sucesso
    console.log('‚úÖ Compra processada:', {
      reference,
      phone,
      email,
      metodo,
      amount: 99
    });

    // 8) resposta final √öNICA
    // Gerar token de upsell ap√≥s compra bem-sucedida
    const upsellToken = gerarUpsellToken({
      phone, metodo, email, nome: nomeCliente, whatsapp, reference
    });
    
    return res.json({ 
      status: 'ok', 
      data: response.data,
      upsellToken: upsellToken,
      redirectUrl: `https://seudominio.com/upsell1?token=${upsellToken}`
    });

  } catch (err) {
    console.error('‚ùå Erro na compra:', err.message);
    
    // Se for erro da API externa, retorna detalhes
    if (err.response) {
      return res.status(err.response.status).json({
        status: 'error',
        message: 'Erro no processamento do pagamento',
        details: err.response.data
      });
    }
    
    // Erro gen√©rico
    return res.status(500).json({
      status: 'error',
      message: 'Erro interno do servidor'
    });
  }
});

/* ---------------------------------------------
   Fun√ß√£o gen√©rica: processarUpsell (ATUALIZADA)
----------------------------------------------*/
async function processarUpsell({ dadosToken, amount, upsellLevel, novaReference }) {
  const { msisdn: phone, method: metodo, email, nome, whatsapp } = dadosToken;
  
  let walletId, authToken;
  if (metodo === 'mpesa') {
    walletId = process.env.MPESA_WALLET_ID;
    authToken = process.env.MPESA_TOKEN;
  } else if (metodo === 'emola') {
    walletId = process.env.EMOLA_WALLET_ID;
    authToken = process.env.EMOLA_TOKEN;
  } else {
    throw new Error('M√©todo inv√°lido. Use mpesa ou emola.');
  }

  const url = `https://mpesaemolatech.com/v1/c2b/${metodo}-payment/${walletId}`;

  // chamada para API externa de pagamento
  const response = await axios.post(
    url,
    {
      client_id: process.env.CLIENT_ID,
      amount: amount.toString(),
      phone,
      reference: novaReference,
    },
    {
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${authToken}`,
      },
    }
  );

  // salva compra no Firebase
  const colecao = `upsell${upsellLevel}_compras`;
  await db.collection(colecao).add({
    nome,
    email,
    phone,
    whatsapp: whatsapp || '',
    metodo,
    amount,
    reference: novaReference,
    parentTxn: dadosToken.parentTxn,
    created_at: new Date(),
  });

  // Gerar pr√≥ximo token de upsell se n√£o for o √∫ltimo
  let proximoToken = null;
  if (upsellLevel < 3) {
    proximoToken = gerarUpsellToken({
      phone, metodo, email, nome, whatsapp, 
      reference: dadosToken.parentTxn // mant√©m refer√™ncia original
    });
  }

  return { 
    paymentData: response.data,
    proximoToken,
    proximoUpsell: upsellLevel < 3 ? upsellLevel + 1 : null
  };
}

/* ---------------------------------------------
   Rotas de Upsell (ATUALIZADAS COM JWT)
----------------------------------------------*/
app.post('/api/upsell1', async (req, res) => {
  const { token } = req.body;
  
  if (!token) {
    return res.status(400).json({ status: 'error', message: 'Token de upsell obrigat√≥rio' });
  }
  
  try {
    // Validar token
    const dadosToken = validarUpsellToken(token);
    
    // Verificar se transa√ß√£o principal existe
    const transacaoValida = await verificarTransacaoPrincipal(dadosToken.parentTxn);
    if (!transacaoValida) {
      return res.status(400).json({ status: 'error', message: 'Transa√ß√£o principal n√£o encontrada' });
    }
    
    // Verificar se upsell j√° foi processado
    const jaProcessado = await verificarUpsellJaProcessado(dadosToken.parentTxn, 1);
    if (jaProcessado) {
      return res.status(400).json({ status: 'error', message: 'Upsell 1 j√° foi processado' });
    }
    
    const resultado = await processarUpsell({
      dadosToken,
      amount: 349,
      upsellLevel: 1,
      novaReference: `UPSELL1-${dadosToken.parentTxn}-${Date.now()}`
    });
    
    const response = { 
      status: 'ok', 
      data: resultado.paymentData 
    };
    
    // Adicionar pr√≥ximo upsell se existir
    if (resultado.proximoToken) {
      response.proximoUpsellToken = resultado.proximoToken;
      response.proximoUpsellUrl = `https://seudominio.com/upsell${resultado.proximoUpsell}?token=${resultado.proximoToken}`;
    }
    
    res.json(response);
  } catch (err) {
    console.error('‚ùå Erro no upsell1:', err.message);
    res.status(500).json({ status: 'error', message: err.message });
  }
});

app.post('/api/upsell2', async (req, res) => {
  const { token } = req.body;
  
  if (!token) {
    return res.status(400).json({ status: 'error', message: 'Token de upsell obrigat√≥rio' });
  }
  
  try {
    const dadosToken = validarUpsellToken(token);
    
    const transacaoValida = await verificarTransacaoPrincipal(dadosToken.parentTxn);
    if (!transacaoValida) {
      return res.status(400).json({ status: 'error', message: 'Transa√ß√£o principal n√£o encontrada' });
    }
    
    const jaProcessado = await verificarUpsellJaProcessado(dadosToken.parentTxn, 2);
    if (jaProcessado) {
      return res.status(400).json({ status: 'error', message: 'Upsell 2 j√° foi processado' });
    }
    
    const resultado = await processarUpsell({
      dadosToken,
      amount: 250,
      upsellLevel: 2,
      novaReference: `UPSELL2-${dadosToken.parentTxn}-${Date.now()}`
    });
    
    const response = { 
      status: 'ok', 
      data: resultado.paymentData 
    };
    
    if (resultado.proximoToken) {
      response.proximoUpsellToken = resultado.proximoToken;
      response.proximoUpsellUrl = `https://seudominio.com/upsell${resultado.proximoUpsell}?token=${resultado.proximoToken}`;
    }
    
    res.json(response);
  } catch (err) {
    console.error('‚ùå Erro no upsell2:', err.message);
    res.status(500).json({ status: 'error', message: err.message });
  }
});

app.post('/api/upsell3', async (req, res) => {
  const { token } = req.body;
  
  if (!token) {
    return res.status(400).json({ status: 'error', message: 'Token de upsell obrigat√≥rio' });
  }
  
  try {
    const dadosToken = validarUpsellToken(token);
    
    const transacaoValida = await verificarTransacaoPrincipal(dadosToken.parentTxn);
    if (!transacaoValida) {
      return res.status(400).json({ status: 'error', message: 'Transa√ß√£o principal n√£o encontrada' });
    }
    
    const jaProcessado = await verificarUpsellJaProcessado(dadosToken.parentTxn, 3);
    if (jaProcessado) {
      return res.status(400).json({ status: 'error', message: 'Upsell 3 j√° foi processado' });
    }
    
    const resultado = await processarUpsell({
      dadosToken,
      amount: 149,
      upsellLevel: 3,
      novaReference: `UPSELL3-${dadosToken.parentTxn}-${Date.now()}`
    });
    
    // √öltimo upsell - n√£o h√° pr√≥ximo
    res.json({ 
      status: 'ok', 
      data: resultado.paymentData,
      finalUpsell: true 
    });
  } catch (err) {
    console.error('‚ùå Erro no upsell3:', err.message);
    res.status(500).json({ status: 'error', message: err.message });
  }
});

/* ---------------------------------------------
   Rota para validar token (opcional - para debug)
----------------------------------------------*/
app.post('/api/validate-token', async (req, res) => {
  const { token } = req.body;
  
  try {
    const dadosToken = validarUpsellToken(token);
    const transacaoValida = await verificarTransacaoPrincipal(dadosToken.parentTxn);
    
    res.json({
      status: 'ok',
      valid: true,
      dados: dadosToken,
      transacaoValida
    });
  } catch (err) {
    res.json({
      status: 'error',
      valid: false,
      message: err.message
    });
  }
});

/* ---------------------------------------------
   Start
----------------------------------------------*/
app.listen(PORT, () => {
  console.log(`üöÄ Servidor rodando na porta ${PORT}`);
});
